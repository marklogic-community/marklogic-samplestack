{
  "id": "/questions/2073510",
  "creationDate": "2014-01-18T09:24:51.607",
  "body": "\n\nI want to find when a collision between a static and a moving ball occurs, but the algorithm I came up with, sometimes doesn't detect a collision and the moving ball goes through the static one. The moving ball is affected by gravity and the static one is not.\n\nHere's my collision detection code:\n\n\tGLfloat whenSpheresCollide(const sphere2d &firstSphere, const sphere2d &secondSphere)\n\t{\n\t    Vector2f relativePosition = subtractVectors(firstSphere.vPosition, secondSphere.vPosition);\n\t    Vector2f relativeVelocity = subtractVectors(firstSphere.vVelocity, secondSphere.vVelocity);\n\t\n\t    GLfloat radiusSum = firstSphere.radius + secondSphere.radius;\n\t\n\t    //We'll find the time when objects collide if a collision takes place\n\t\n\t    //r(t) = P[0] + t * V[0]\n\t    //\n\t    //d^2(t) = P[0]^2 + 2 * t * P[0] * V[0] + t^2 * V[0]^2\n\t    //\n\t    //d^2(t) = V[0]^2 * t^2 + 2t( P[0] . V[0] ) + P[0]^2\n\t    //\n\t    //d(t) = R\n\t    //\n\t    //d(t)^2 = R^2\n\t    //\n\t    //V[0]^2 * t^2 + 2t( P[0] . V[0] ) + P[0]^2 - R^2 = 0\n\t    //\n\t    //delta = ( P[0] . V[0] )^2 - V[0]^2 * (P[0]^2 - R^2)\n\t    //\n\t    //  We are interested in the lowest t:\n\t    //\n\t    //t = ( -( P[0] . V[0] ) - sqrt(delta) ) / V[0]^2\n\t    //\n\t\n\t    GLfloat equationDelta = squaref( dotProduct(relativePosition, relativeVelocity) ) - squarev( relativeVelocity ) * ( squarev( relativePosition ) - squaref(radiusSum)  );\n\t\n\t    if (equationDelta >= 0.0f)\n\t    {\n\t        GLfloat collisionTime = ( - dotProduct(relativePosition, relativeVelocity) - sqrtf(equationDelta) ) / squarev(relativeVelocity);\n\t\n\t        if (collisionTime >= 0.0f && collisionTime <= 1.0f / GAME_FPS)\n\t        {\n\t            return collisionTime;\n\t        }\n\t    }\n\t\n\t    return -1.0f;\n\t}\n\t\n\nAnd here is the updating function that calls collision detection:\n\n\tvoid GamePhysicsManager::updateBallPhysics()\n\t{\n\t    //\n\t    //Update velocity\n\t    vVelocity->y -= constG / GAME_FPS;  //v = a * t = g * 1 sec / (updates per second)\n\t\n\t    shouldApplyForcesToBall = TRUE;\n\t\n\t    vPosition->x += vVelocity->x / GAME_FPS;\n\t    vPosition->y += vVelocity->y / GAME_FPS;\n\t\n\t    if ( distanceBetweenVectors( *pBall->getPositionVector(), *pBasket->getPositionVector() ) <= pBasket->getRadius() + vectorLength(*vVelocity) / GAME_FPS )\n\t    {\n\t        //Ball sphere\n\t        sphere2d ballSphere;\n\t        ballSphere.radius = pBall->getRadius();\n\t        ballSphere.mass = 1.0f;\n\t        ballSphere.vPosition = *( pBall->getPositionVector() );\n\t        ballSphere.vVelocity = *( pBall->getVelocityVector() );\n\t\n\t\n\t        sphere2d ringSphereRight;\n\t        ringSphereRight.radius = 0.05f;\n\t        ringSphereRight.mass = -1.0f;\n\t        ringSphereRight.vPosition = *( pBasket->getPositionVector() );\n\t        //ringSphereRight.vPosition.x += pBasket->getRadius();\n\t        ringSphereRight.vPosition.x += (pBasket->getRadius() - ringSphereRight.radius);\n\t        ringSphereRight.vVelocity = zeroVector();\n\t\n\t\n\t        GLfloat collisionTime = whenSpheresCollide(ballSphere, ringSphereRight);\n\t\n\t        if ( collisionTime >= 0.0f )\n\t        {\n\t            DebugLog(\"collision\");\n\t            respondToCollision(&ballSphere, &ringSphereRight, collisionTime, pBall->getRestitution() * 0.75f );\n\t        }\n\t\n\t        //\n\t        //Implement selection of the results that are first to collide collision\n\t\n\t        vVelocity->x = ballSphere.vVelocity.x;\n\t        vVelocity->y = ballSphere.vVelocity.y;\n\t\n\t        vPosition->x = ballSphere.vPosition.x;\n\t        vPosition->y = ballSphere.vPosition.y;\n\t    }\n\t\n\nWhy isn't the collision being detected in 100% of cases? It's being detected only in 70% of cases.\nThanks.\n\nUPDATE: Problem seems to be solved when I change FPS from 30 to 10. How does FPS affect my collision detection?",
  "lastActivityDate": "2014-01-18T10:57:10.547",
  "title": "simple 2d collision problem",
  "tags": [
    "c++",
    "collision-detection",
    "computational-geometry"
  ],
  "docScore": 0,
  "comments": [],
  "answers": [],
  "creationYearMonth": "201401",
  "itemTally": 0,
  "owner": null
}