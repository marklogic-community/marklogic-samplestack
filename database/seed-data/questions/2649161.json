{
  "id": "/questions/2649161",
  "creationDate": "2014-04-18T05:39:11.273",
  "body": "\n\nI'd like to write some code that runs a sequence of F# scripts (.fsx). The thing is that I could have literally hundreds of scripts and if I do that:\n\n\tlet shellExecute program args =\n\t    let startInfo = new ProcessStartInfo()\n\t    do startInfo.FileName        <- program\n\t    do startInfo.Arguments       <- args\n\t    do startInfo.UseShellExecute <- true\n\t    do startInfo.WindowStyle     <- ProcessWindowStyle.Hidden\n\t\n\t    //do printfn \"%s\" startInfo.Arguments \n\t    let proc = Process.Start(startInfo)\n\t    ()\n\t\n\tscripts\n\t|> Seq.iter (shellExecute \"fsi\")\n\t\n\nit *could* stress too much my 2GB system. Anyway, I'd like to run scripts by batch of n, which seems also a good exercise for learning `Async` (I guess it's the way to go).\n\nI have started to write some code for that but unfortunately it doesn't work:\n\n\topen System.Diagnostics\n\t\n\tlet p = shellExecute \"fsi\" @\"C:\\Users\\Stringer\\foo.fsx\"\n\t\n\tasync {\n\t    let! exit = Async.AwaitEvent p.Exited\n\t    do printfn \"process has exited\"\n\t}\n\t|> Async.StartImmediate\n\t\n\nfoo.fsx is just a hello world script.\nWhat would be the most idiomatic way of solving this problem?\n\nI'd like also to figure out if it's doable to retrieve a return code for each executing script and if not, find another way. Thanks!\n\nEDIT:\n\nThanks a lot for your insights and links! I've learned a lot.\nI just want to add some code for running batchs in parallel using `Async.Parallel` as Tomas suggested it. Please comment if there is a better implementation for my `cut` function.\n\n\tmodule Seq =\n\t  /// Returns a sequence of sequences of N elements from the source sequence.\n\t  /// If the length of the source sequence is not a multiple\n\t  /// of N, last element of the returned sequence will have a length\n\t  /// included between 1 and N-1.\n\t  let cut (count : int) (source : seq<´T>) = \n\t    let rec aux s length = seq {\n\t      if (length < count) then yield s\n\t      else\n\t        yield Seq.take count s\n\t        if (length <> count) then\n\t          yield! aux (Seq.skip count s) (length - count)\n\t      }\n\t    aux source (Seq.length source)\n\t\n\tlet batchCount = 2\n\tlet filesPerBatch =\n\t  let q = (scripts.Length / batchCount)\n\t  q + if scripts.Length % batchCount = 0 then 0 else 1\n\t\n\tlet batchs =\n\t  scripts\n\t  |> Seq.cut filesPerBatch\n\t  |> Seq.map Seq.toList\n\t  |> Seq.map loop\n\t\n\tAsync.RunSynchronously (Async.Parallel batchs) |> ignore\n\t\n\nEDIT2:\n\nSo I had some troubles to get Tomas's guard code working. I guess the `f` function had to be called in `AddHandler` method, otherwise we loose the event for ever... Here's the code:\n\n\tmodule Event =\n\t  let guard f (e:IEvent<´Del, ´Args>) = \n\t    let e = Event.map id e\n\t    { new IEvent<´Args> with \n\t        member this.AddHandler(d) = e.AddHandler(d); f() //must call f here!\n\t        member this.RemoveHandler(d) = e.RemoveHandler(d); f()\n\t        member this.Subscribe(observer) = \n\t          let rm = e.Subscribe(observer) in f(); rm }\n\t\n\nThe interesting thing (as mentioned by Tomas) is that it looks like the `Exited` event is stored somewhere when the process terminates, even though the process has not started with `EnableRaisingEvents` set to true.\nWhen this property is finally set to true, the event is fired up.\n\nSince I'm not sure that this is the official specification (and also a bit paranoid), I found another solution that consists in starting the process in the `guard` function, so we ensure that the code will work on whichever situation:\n\n\tlet createStartInfo program args =\n\t  new ProcessStartInfo\n\t    (FileName = program, Arguments = args, UseShellExecute = false,\n\t     WindowStyle = ProcessWindowStyle.Normal, \n\t     RedirectStandardOutput = true)\n\t\n\tlet createProcess info =\n\t  let p = new Process()\n\t  do p.StartInfo           <- info\n\t  do p.EnableRaisingEvents <- true\n\t  p\n\t\n\tlet rec loop scripts = async { \n\t  match scripts with \n\t  | [] -> printfn \"FINISHED\"\n\t  | script::scripts ->\n\t    let args = sprintf \"\\\"%s\\\"\" script\n\t    let p = createStartInfo \"notepad\" args |> createProcess\n\t    let! exit =\n\t      p.Exited \n\t      |> Event.guard (fun () -> p.Start() |> ignore)\n\t      |> Async.AwaitEvent\n\t    let output = p.StandardOutput.ReadToEnd()\n\t    do printfn \"\\nPROCESSED: %s, CODE: %d, OUTPUT: %A\"script p.ExitCode output\n\t    return! loop scripts \n\t  }\n\t\n\nNotice I've replaced *fsi.exe* by *notepad.exe* so I can replay different scenarios step by step in the debugger and control explicitly the exit of the process myself.",
  "lastActivityDate": "2014-06-26T12:00:17.747",
  "title": "Need help regarding Async and fsi",
  "tags": [
    "f#",
    "sequence",
    "asynchronous",
    "f#-interactive"
  ],
  "docScore": 0,
  "comments": [],
  "answers": [],
  "creationYearMonth": "201406",
  "itemTally": 0,
  "owner": null
}