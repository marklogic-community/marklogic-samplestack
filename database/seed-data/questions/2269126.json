{
  "id": "/questions/2269126",
  "creationDate": "2014-02-18T13:41:22.733",
  "body": "\n\nAlright, possible a naive question here. I have a service that needs to log into multiple network devices, run a command on each and collect the results.  For speed, rather than collect the information on each device in sequence, I need to access them all concurrently and consume the results after they are done. \n\nUsing the Spring framework and Jsch I'm quite easily able to query each device correctly.  Where I am running into some confusion is in trying to rewire the beans to use TaskExecutor to accomplish this. What I can't figure out how to do is how to know when the thread is finished.\n\nWhat I have so far is this:\n\n\tpublic class RemoteCommand {\n\t\n\t    private String user;\n\t    private String host;\n\t    private String password;\n\t    private String command;\n\t    private List<String> commandResults;\n\t    private TaskExecutor taskExecutor;\n\t\n\t    public RemoteCommand(String user, String host, String password, TaskExecutor taskExecutor) {\n\t\n\t        setUser(user);\n\t        setHost(host);\n\t        setPassword(password);\n\t        setTaskExecutor(taskExecutor);\n\t    }\n\t\n\t    /**\n\t     * @param user the user to set\n\t     */\n\t    public void setUser(String user) {\n\t        this.user = user;\n\t    }\n\t\n\t    /**\n\t     * @return the user\n\t     */\n\t    public String getUser() {\n\t        return user;\n\t    }\n\t\n\t    /**\n\t     * @param host the host to set\n\t     */\n\t    public void setHost(String host) {\n\t        this.host = host;\n\t    }\n\t\n\t    /**\n\t     * @return the host\n\t     */\n\t    public String getHost() {\n\t        return host;\n\t    }\n\t\n\t    /**\n\t     * @param password the password to set\n\t     */\n\t    public void setPassword(String password) {\n\t        this.password = password;\n\t    }\n\t\n\t    /**\n\t     * @return the password\n\t     */\n\t    public String getPassword() {\n\t        return password;\n\t    }\n\t\n\t    /**\n\t     * @param command the command to set\n\t     */\n\t    private void setCommand(String command) {\n\t        this.command = command;\n\t    }\n\t\n\t    /**\n\t     * @return the command\n\t     */\n\t    private String getCommand() {\n\t        return command;\n\t    }\n\t\n\t    /**\n\t     * @param commandResults the commandResults to set\n\t     */\n\t    private void setCommandResults(List<String> commandResults) {\n\t        this.commandResults = commandResults;\n\t    }\n\t\n\t    /**\n\t     * @return the commandResults\n\t     */\n\t    public List<String> getCommandResults(String command) {\n\t        taskExecutor.execute(new CommandTask(command) );\n\t\n\t        return commandResults;\n\t    }\n\t\n\t    /**\n\t     * @param taskExecutor the taskExecutor to set\n\t     */\n\t    public void setTaskExecutor(TaskExecutor taskExecutor) {\n\t        this.taskExecutor = taskExecutor;\n\t    }\n\t\n\t    /**\n\t     * @return the taskExecutor\n\t     */\n\t    public TaskExecutor getTaskExecutor() {\n\t        return taskExecutor;\n\t    }\n\t\n\t    private class CommandTask implements Runnable {\n\t\n\t        public CommandTask(String command) {\n\t            setCommand(command);\n\t            System.out.println(\"test: \" + getCommand());\n\t        }\n\t\n\t        /**\n\t         * \n\t         * @param command\n\t         */\n\t        public void run() {\n\t\n\t            List<String> results = new LinkedList<String>();\n\t            String command = getCommand();\n\t\n\t            try {\n\t                System.out.println(\"running\");\n\t                JSch jsch = new JSch();\n\t\n\t                String user = getUser();\n\t                String host = getHost();\n\t\n\t                java.util.Properties config = new java.util.Properties(); \n\t                config.put(\"StrictHostKeyChecking\", \"no\");\n\t\n\t                host = host.substring(host.indexOf('@') + 1);\n\t                Session session = jsch.getSession(user, host, 22);\n\t\n\t                session.setPassword(getPassword());\n\t                session.setConfig(config);\n\t                session.connect();\n\t\n\t                Channel channel = session.openChannel(\"exec\");\n\t                ((ChannelExec) channel).setCommand(command);\n\t\n\t                channel.setInputStream(null);\n\t\n\t                ((ChannelExec) channel).setErrStream(System.err);\n\t\n\t                InputStream in = channel.getInputStream();\n\t\n\t                channel.connect();\n\t                byte[] tmp = new byte[1024];\n\t                while (true) {\n\t                    while (in.available() > 0) {\n\t                        int i = in.read(tmp, 0, 1024);\n\t                        if (i < 0)\n\t                            break;\n\t                        results.add(new String(tmp, 0, i));\n\t                        System.out.print(new String(tmp, 0, i));\n\t                    }\n\t                    if (channel.isClosed()) {\n\t                        //System.out.println(\"exit-status: \"\n\t                        //      + channel.getExitStatus());\n\t                        break;\n\t                    }\n\t                    try {\n\t                        Thread.sleep(1000);\n\t                    } catch (Exception ee) {\n\t                        ee.printStackTrace();\n\t                    }\n\t                }\n\t                channel.disconnect();\n\t                session.disconnect();\n\t            } catch (Exception e) {\n\t                System.out.println(e);\n\t            }\n\t            setCommandResults(results);\n\t            System.out.println(\"finished running\");\n\t        }\n\t    }\n\t}\n\t\n\nWithin my junit test I have:\n\n\t@Test\n\t    public void testRemoteExecution() {\n\t\n\t        remoteCommand = (RemoteCommand) applicationContext.getBean(\"remoteCommand\");\n\t        remoteCommand.getCommandResults(\"scripts/something.pl xxx.xxx.xxx.xxx\");\n\t\n\t            //List<String> results = remoteCommand.getCommandResults(\"scripts/something.pl xxx.xxx.xxx.xxx\");\n\t        //for (String line : results) {\n\t        //  System.out.println(line.trim());\n\t        //}\n\t    }\n\t\n\nMy applicationContext.xml file:\n\n\t    <bean id=\"taskExecutor\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\">\n\t       <property name=\"corePoolSize\" value=\"5\" />\n\t       <property name=\"maxPoolSize\" value=\"10\" />\n\t       <property name=\"queueCapacity\" value=\"25\" />\n\t    </bean>        \n\t\n\t<!-- ******************** -->\n\t<!--      Utilities       -->\n\t<!-- ******************** -->\n\t\n\t     <bean name=\"remoteCommand\" class=\"com.xxx.ncc.sonet.utilities.RemoteCommand\" scope=\"prototype\">\n\t        <description>Remote Command</description>\n\t        <constructor-arg><value>${remote.user}</value></constructor-arg>\n\t        <constructor-arg><value>${remote.host}</value></constructor-arg>\n\t        <constructor-arg><value>${remote.password}</value></constructor-arg>\n\t        <constructor-arg ref=\"taskExecutor\" />\n\t    </bean> \n\t\n\nI get as far as the first println in the run() method. Then the test exits cleanly with no errors. I never get to the second println at the bottom of that routine. I've looked at this thread [here](http://stackoverflow.com/questions/702415/how-to-know-if-other-threads-have-finished), which was very useful, but not implemented in a Spring specific fashion.  I'm sure I'm missing something simple, or have completely run off the rails here.  Any help is appreciated.",
  "lastActivityDate": "2014-02-18T13:54:45.937",
  "title": "Using Spring threading and TaskExecutor, how do I know when a thread is finished?",
  "tags": [
    "java",
    "spring",
    "multithreading"
  ],
  "docScore": 0,
  "comments": [],
  "answers": [],
  "creationYearMonth": "201402",
  "itemTally": 0,
  "owner": null
}