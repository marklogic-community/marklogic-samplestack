{
  "id": "/questions/2448187",
  "creationDate": "2014-03-17T23:17:17.930",
  "body": "\n\nI find functools.partial to be extremely useful, but I would like to be able to freeze arguments out of order (the argument you want to freeze is not always the first one) and I'd like to be able to apply it to several methods on a class at once, to make a proxy object that has the same methods as the underlying object except with some of its methods parameters being frozen (think of it as generalizing partial to apply to classes). And I'd prefer to do this without editing the original object, just like partial doesn't change its original function.\n\nI've managed to scrap together a version of functools.partial called 'bind' that lets me specify parameters out of order by passing them by keyword argument. That part works:\n\n\t>>> def foo(x, y):\n\t...     print x, y\n\t...\n\t>>> bar = bind(foo, y=3)\n\t>>> bar(2)\n\t2 3\n\t\n\nBut my proxy class does not work, and I'm not sure why:\n\n\t>>> class Foo(object):\n\t...     def bar(self, x, y):\n\t...             print x, y\n\t...\n\t>>> a = Foo()\n\t>>> b = PureProxy(a, bar=bind(Foo.bar, y=3))\n\t>>> b.bar(2)\n\tTraceback (most recent call last):\n\t  File \"<stdin>\", line 1, in <module>\n\tTypeError: bar() takes exactly 3 arguments (2 given)\n\t\n\nI'm probably doing this all sorts of wrong because I'm just going by what I've pieced together from random documentation, blogs, and running dir() on all the pieces. Suggestions both on how to make this work and better ways to implement it would be appreciated ;) One detail I'm unsure about is how this should all interact with descriptors. Code follows.\n\n\tfrom types import MethodType\n\t\n\tclass PureProxy(object):\n\t    def __init__(self, underlying, **substitutions):\n\t        self.underlying = underlying\n\t\n\t        for name in substitutions:\n\t            subst_attr = substitutions[name]\n\t            if hasattr(subst_attr, \"underlying\"):\n\t                setattr(self, name, MethodType(subst_attr, self, PureProxy))\n\t\n\t    def __getattribute__(self, name):\n\t        return getattr(object.__getattribute__(self, \"underlying\"), name)\n\t\n\tdef bind(f, *args, **kwargs):\n\t    \"\"\" Lets you freeze arguments of a function be certain values. Unlike\n\t    functools.partial, you can freeze arguments by name, which has the bonus\n\t    of letting you freeze them out of order. args will be treated just like\n\t    partial, but kwargs will properly take into account if you are specifying\n\t    a regular argument by name. \"\"\"\n\t    argspec = inspect.getargspec(f)\n\t    argdict = copy(kwargs)\n\t\n\t    if hasattr(f, \"im_func\"):\n\t        f = f.im_func\n\t\n\t    args_idx = 0\n\t    for arg in argspec.args:\n\t        if args_idx >= len(args):\n\t            break\n\t\n\t        argdict[arg] = args[args_idx]\n\t        args_idx += 1\n\t\n\t    num_plugged = args_idx\n\t\n\t    def new_func(*inner_args, **inner_kwargs):\n\t        args_idx = 0\n\t        for arg in argspec.args[num_plugged:]:\n\t            if arg in argdict:\n\t                continue\n\t            if args_idx >= len(inner_args):\n\t                # We can't raise an error here because some remaining arguments\n\t                # may have been passed in by keyword.\n\t                break\n\t            argdict[arg] = inner_args[args_idx]\n\t            args_idx += 1\n\t\n\t        f(**dict(argdict, **inner_kwargs))\n\t\n\t    new_func.underlying = f\n\t\n\t    return new_func\n\t\n\nUpdate: In case anyone can benefit, here's the final implementation I went with:\n\n\tfrom types import MethodType\n\t\n\tclass PureProxy(object):\n\t    \"\"\" Intended usage:\n\t    >>> class Foo(object):\n\t    ...     def bar(self, x, y):\n\t    ...             print x, y\n\t    ...\n\t    >>> a = Foo()\n\t    >>> b = PureProxy(a, bar=FreezeArgs(y=3))\n\t    >>> b.bar(1)\n\t    1 3\n\t    \"\"\"\n\t\n\t    def __init__(self, underlying, **substitutions):\n\t        self.underlying = underlying\n\t\n\t        for name in substitutions:\n\t            subst_attr = substitutions[name]\n\t            if isinstance(subst_attr, FreezeArgs):\n\t                underlying_func = getattr(underlying, name)\n\t                new_method_func = bind(underlying_func, *subst_attr.args, **subst_attr.kwargs)\n\t                setattr(self, name, MethodType(new_method_func, self, PureProxy))\n\t\n\t    def __getattr__(self, name):\n\t        return getattr(self.underlying, name)\n\t\n\tclass FreezeArgs(object):\n\t    def __init__(self, *args, **kwargs):\n\t        self.args = args\n\t        self.kwargs = kwargs\n\t\n\tdef bind(f, *args, **kwargs):\n\t    \"\"\" Lets you freeze arguments of a function be certain values. Unlike\n\t    functools.partial, you can freeze arguments by name, which has the bonus\n\t    of letting you freeze them out of order. args will be treated just like\n\t    partial, but kwargs will properly take into account if you are specifying\n\t    a regular argument by name. \"\"\"\n\t    argspec = inspect.getargspec(f)\n\t    argdict = copy(kwargs)\n\t\n\t    if hasattr(f, \"im_func\"):\n\t        f = f.im_func\n\t\n\t    args_idx = 0\n\t    for arg in argspec.args:\n\t        if args_idx >= len(args):\n\t            break\n\t\n\t        argdict[arg] = args[args_idx]\n\t        args_idx += 1\n\t\n\t    num_plugged = args_idx\n\t\n\t    def new_func(*inner_args, **inner_kwargs):\n\t        args_idx = 0\n\t        for arg in argspec.args[num_plugged:]:\n\t            if arg in argdict:\n\t                continue\n\t            if args_idx >= len(inner_args):\n\t                # We can't raise an error here because some remaining arguments\n\t                # may have been passed in by keyword.\n\t                break\n\t            argdict[arg] = inner_args[args_idx]\n\t            args_idx += 1\n\t\n\t        f(**dict(argdict, **inner_kwargs))\n\t\n\t    return new_func\n\t",
  "lastActivityDate": "2014-03-18T04:51:07.353",
  "title": "How can I use functools.partial on multiple methods on an object, and freeze parameters out of order?",
  "tags": [
    "functional-programming",
    "metaprogramming",
    "python",
    "standard-library"
  ],
  "docScore": 0,
  "comments": [],
  "answers": [],
  "creationYearMonth": "201403",
  "itemTally": 0,
  "owner": null
}