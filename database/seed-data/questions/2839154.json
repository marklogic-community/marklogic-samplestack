{
  "id": "/questions/2839154",
  "creationDate": "2014-05-17T14:25:57.560",
  "body": "\n\nI've tried this a couple ways, the first is have a class that implements comparator at the bottom of the following code.  When I try to pass the comparat in sortListByLastName, I get a constructor not found error and I am not sure why\n\n\timport java.util.*;\n\t\n\tpublic class OrganizeThis implements WhoDoneIt\n\t{\n\t    /** \n\t    Add a person to the organizer\n\t\n\t    @param p A person object\n\t    */\n\t    public void add(Person p)\n\t    {   \n\t        staff.put(p.getEmail(), p);\n\t        //System.out.println(\"Person \" + p + \"added\");\n\t    }\n\t\n\t    /**\n\t    * Remove a Person from the organizer.\n\t    *\n\t    * @param email The email of the person to be removed.\n\t    */\n\t    public void remove(String email)\n\t    {\n\t        staff.remove(email);\n\t    }\n\t\n\t    /**\n\t    * Remove all contacts from the organizer.\n\t    *\n\t    */\n\t    public void empty()\n\t    {\n\t        staff.clear();\n\t    }\n\t\n\t    /**\n\t    * Find the person stored in the organizer with the email address.\n\t    * Note, each person will have a unique email address.\n\t    * \n\t    * @param email The person email address you are looking for.\n\t    *\n\t    */\n\t    public Person findByEmail(String email)\n\t    {\n\t        Person aPerson = staff.get(email);\n\t        return aPerson;\n\t    }\n\t\n\t    /**\n\t    * Find all persons stored in the organizer with the same last name.\n\t    * Note, there can be multiple persons with the same last name.\n\t    * \n\t    * @param lastName The last name of the persons your are looking for.\n\t    *\n\t    */\n\t    public Person[] find(String lastName)\n\t    {\n\t        ArrayList<Person> names = new ArrayList<Person>();\n\t\n\t        for (Person s : staff.values())\n\t        {\n\t            if (s.getLastName() == lastName) {\n\t                names.add(s);\n\t            }\n\t        }\n\t        // Convert ArrayList back to Array\n\t        Person nameArray[] = new Person[names.size()];\n\t        names.toArray(nameArray);\n\t        return nameArray;\n\t    }\n\t\n\t    /**\n\t    * Return all the contact from the orgnizer in\n\t    * an array sorted by last name.\n\t    * \n\t    * @return An array of Person objects.\n\t    *\n\t    */\n\t    public Person[] getSortedListByLastName()\n\t    {\n\t        PersonLastNameComparator comp = new PersonLastNameComparator();\n\t        Map<String, Person> sorted = new TreeMap<String, Person>(comp);\n\t\n\t\n\t        ArrayList<Person> sortedArrayList = new ArrayList<Person>();\n\t        for (Person s: sorted.values()) {\n\t            sortedArrayList.add(s);\n\t        }\n\t        Person sortedArray[] = new Person[sortedArrayList.size()];\n\t        sortedArrayList.toArray(sortedArray);\n\t        return sortedArray;\n\t    }\n\t\n\t\n\t    private Map<String, Person> staff = new HashMap<String, Person>();\n\t\n\t    public static void main(String[] args)\n\t    {\n\t        OrganizeThis testObj = new OrganizeThis();\n\t        Person person1 = new Person(\"J\", \"W\", \"111-222-3333\", \"JW@ucsd.edu\");\n\t        Person person2 = new Person(\"K\", \"W\", \"345-678-9999\", \"KW@ucsd.edu\");\n\t        Person person3 = new Person(\"Phoebe\", \"Wang\", \"322-111-3333\", \"phoebe@ucsd.edu\");\n\t        Person person4 = new Person(\"Nermal\", \"Johnson\", \"322-342-5555\", \"nermal@ucsd.edu\");\n\t        Person person5 = new Person(\"Apple\", \"Banana\", \"123-456-1111\", \"apple@ucsd.edu\");\n\t        testObj.add(person1);\n\t        testObj.add(person2);\n\t        testObj.add(person3);\n\t        testObj.add(person4);\n\t        testObj.add(person5);\n\t\n\t        System.out.println(testObj.findByEmail(\"JW@ucsd.edu\"));\n\t        System.out.println(\"------------\" + '\\n');\n\t\n\t        Person a[] = testObj.find(\"W\");\n\t\n\t        for (Person p : a)\n\t        System.out.println(p);\n\t\n\t        System.out.println(\"------------\" + '\\n');\n\t        a = testObj.find(\"W\");\n\t\n\t        for (Person p : a)\n\t        System.out.println(p);\n\t\n\t        System.out.println(\"SORTED\" + '\\n');\n\t        a = testObj.getSortedListByLastName();\n\t        for (Person b : a) {\n\t            System.out.println(b);\n\t        }\n\t\n\t        System.out.println(testObj.getAuthor());\n\t    }\n\t}\n\t\n\tclass PersonLastNameComparator implements Comparator<Person>\n\t{\n\t    public int compare(Person a, Person b)\n\t    {\n\t        return a.getLastName().compareTo(b.getLastName());\n\t    }\n\t}\n\t\n\nAnd then when I tried doing it by creating an anonymous inner class, I also get a constructor TreeMap cannot find symbol error.  Any thoughts?  \n\ninner class method:\n\n\tpublic Person[] getSortedListByLastName()\n\t    {\n\t        //PersonLastNameComparator comp = new PersonLastNameComparator();\n\t        Map<String, Person> sorted = new TreeMap<String, Person>(new Comparator<Person>()\n\t        {\n\t                public int compare(Person a, Person b)\n\t    {\n\t        return a.getLastName().compareTo(b.getLastName());\n\t    }\n\t    });\n\t\n\t\n\t        ArrayList<Person> sortedArrayList = new ArrayList<Person>();\n\t        for (Person s: sorted.values()) {\n\t            sortedArrayList.add(s);\n\t        }\n\t        Person sortedArray[] = new Person[sortedArrayList.size()];\n\t        sortedArrayList.toArray(sortedArray);\n\t        return sortedArray;\n\t    }\n\t",
  "lastActivityDate": "2014-06-12T22:03:52.470",
  "title": "Passing a comparator syntax help in Java",
  "tags": [
    "java",
    "collections",
    "comparator"
  ],
  "docScore": 0,
  "comments": [],
  "answers": [],
  "creationYearMonth": "201406",
  "itemTally": 0,
  "owner": null
}